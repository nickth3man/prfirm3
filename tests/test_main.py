# Autogenerated tests for main.py using pytest

# === AUTO-GENERATED TESTS FOR main.py (Virtual PR Firm CLI/Gradio) BEGIN ===
"""
Test suite for the Virtual PR Firm demo module.

Testing library and framework:
- pytest (function-style tests with fixtures: capsys, monkeypatch)
- unittest.mock where convenient for sentinels

Focus:
- run_demo(): validates shared store, constructs flow via create_main_flow, runs it, prints results
- validate_shared_store(): schema/type checks
- create_gradio_interface(): raises when gr is unavailable; builds UI and wires click handler.
  Uses a fake 'gr' to simulate Blocks/Textbox/JSON/Button wiring and to exercise inner run_flow.
"""

from typing import Any, NoReturn
import pytest

# Import the module under test.
# It is expected to be named 'main' per provided source. If repository uses a package layout,
# the import machinery will still resolve 'main' from repo root.
import main as main_mod


class _FakeFlow:
    """A lightweight fake Flow with a run() that writes deterministic outputs."""
    def __init__(self) -> None:
        self.runs = []

    def run(self, shared: dict[str, Any]) -> None:
        self.runs.append(shared)
        # Synthesize predictable content_pieces for platforms in shared
        tr = shared.get("task_requirements", {})
        platforms = tr.get("platforms") or []
        topic = tr.get("topic_or_goal", "")
        shared["content_pieces"] = {p: f"Draft for {p}: {topic}" for p in platforms}


def _patch_create_main_flow(monkeypatch: pytest.MonkeyPatch) -> _FakeFlow:
    """Patch main_mod.create_main_flow to return our _FakeFlow instance."""
    fake = _FakeFlow()

    def _factory() -> _FakeFlow:
        return fake

    monkeypatch.setattr(main_mod, "create_main_flow", _factory)
    return fake


# -----------------------
# validate_shared_store()
# -----------------------

@pytest.mark.parametrize("bad", [
    123,  # not a dict
    3.14,
    None,
    "string",
    [],
])
def test_validate_shared_store_non_dict_raises_typeerror(bad: Any) -> None:
    with pytest.raises(TypeError, match="shared must be a dict"):
        main_mod.validate_shared_store(bad)  # type: ignore[arg-type]


def test_validate_shared_store_missing_task_requirements_raises_valueerror() -> None:
    with pytest.raises(ValueError, match="task_requirements.*must be a dict"):
        main_mod.validate_shared_store({})


def test_validate_shared_store_task_requirements_not_dict_raises_valueerror() -> None:
    with pytest.raises(ValueError, match="must be a dict"):
        main_mod.validate_shared_store({"task_requirements": "not a dict"})  # type: ignore[arg-type]


def test_validate_shared_store_missing_platforms_raises_valueerror() -> None:
    with pytest.raises(ValueError, match="must include 'platforms'"):
        main_mod.validate_shared_store({"task_requirements": {}})


@pytest.mark.parametrize("platforms", [
    "twitter",  # not a list
    42,
    None,
    {"twitter"},
])
def test_validate_shared_store_platforms_wrong_type_raises_typeerror(platforms: Any) -> None:
    with pytest.raises(TypeError, match=r"platforms.*must be a list"):
        main_mod.validate_shared_store({"task_requirements": {"platforms": platforms}})  # type: ignore[arg-type]


def test_validate_shared_store_valid_minimal_ok() -> None:
    # Should not raise
    main_mod.validate_shared_store({"task_requirements": {"platforms": []}})


# ----------
# run_demo()
# ----------

def test_run_demo_invokes_flow_and_prints_content(capsys: Any, monkeypatch: Any) -> None:
    fake_flow = _patch_create_main_flow(monkeypatch)

    # Ensure validate_shared_store passes to avoid raising
    # Call
    main_mod.run_demo()

    # Verify flow was invoked with expected shared content
    assert len(fake_flow.runs) == 1
    shared = fake_flow.runs[0]
    assert shared["task_requirements"]["platforms"] == ["twitter", "linkedin"]
    assert "topic_or_goal" in shared["task_requirements"]

    # Output printed
    out = capsys.readouterr().out
    assert "Content pieces:" in out
    # Our fake wrote content_pieces for the provided platforms
    assert "Draft for twitter" in out
    assert "Draft for linkedin" in out


def test_run_demo_propagates_validation_error(monkeypatch: Any) -> None:
    # Force validate_shared_store to raise and ensure run_demo re-raises after logging

    def _boom(_: Any) -> NoReturn:
        msg = "bad shared"
        raise ValueError(msg)

    monkeypatch.setattr(main_mod, "validate_shared_store", _boom)
    with pytest.raises(ValueError, match="bad shared"):
        main_mod.run_demo()


# -------------------------
# create_gradio_interface()
# -------------------------

def test_create_gradio_interface_raises_when_gr_none(monkeypatch: Any) -> None:
    # Simulate environment without gradio
    monkeypatch.setattr(main_mod, "gr", None)
    with pytest.raises(RuntimeError, match="Gradio not installed"):
        main_mod.create_gradio_interface()


class FakeTextbox:
    def __init__(self, label: str, value: str = "") -> None:
        self.label = label
        self.value = value


class FakeJSON:
    def __init__(self, label: str) -> None:
        self.label = label


class FakeButton:
    def __init__(self, label: str) -> None:
        self.label = label
        self._clicks = []

    def click(self, fn: Any, inputs: Any, outputs: Any) -> None:
        # Store wiring for tests to call fn later
        self._clicks.append({"fn": fn, "inputs": inputs, "outputs": outputs})


class FakeMarkdown:
    def __init__(self, text: str) -> None:
        self.text = text


class FakeBlocks:
    """Minimal context manager emulating gr.Blocks with ability to trigger the click fn."""
    def __init__(self) -> None:
        self.components = []
        self.buttons = []
        self.textboxes = []
        self.jsons = []
        self.markdown = None
        self._last_click = None

    def __enter__(self) -> "FakeBlocks":
        # Within 'with gr.Blocks() as demo:' the variable 'demo' refers to this instance
        return self

    def __exit__(self, exc_type: Any, exc: Any, tb: Any) -> bool:
        return False  # don't suppress

    # Component factory functions wired like gr.* classes
    def Textbox(self, label: str, value: str = "") -> FakeTextbox:
        tb = FakeTextbox(label, value)
        self.textboxes.append(tb)
        self.components.append(tb)
        return tb

    def JSON(self, label: str) -> FakeJSON:
        j = FakeJSON(label)
        self.jsons.append(j)
        self.components.append(j)
        return j

    def Button(self, label: str) -> FakeButton:
        btn = FakeButton(label)
        self.buttons.append(btn)
        self.components.append(btn)
        # Wrap the click to capture last handler
        orig_click = btn.click

        def _click(fn: Any, inputs: Any, outputs: Any) -> None:
            self._last_click = {"fn": fn, "inputs": inputs, "outputs": outputs}
            return orig_click(fn, inputs, outputs)

        btn.click = _click
        return btn

    def Markdown(self, text: str) -> FakeMarkdown:
        self.markdown = FakeMarkdown(text)
        self.components.append(self.markdown)
        return self.markdown

    # Helper for tests to call the last-wired run_flow
    def test_run(self, topic: str, platforms: str) -> dict[str, Any]:
        assert self._last_click is not None, "No click handler wired"
        fn = self._last_click["fn"]
        return fn(topic, platforms)


class FakeGradioModule:
    """Namespace-like object that exposes classes as attributes, like import gradio as gr."""
    def __init__(self) -> None:
        # In Gradio, Textbox/JSON/Button are accessed as gr.Textbox etc.
        self.Blocks = FakeBlocks
        self.Textbox = FakeTextbox
        self.JSON = FakeJSON
        self.Button = FakeButton
        self.Markdown = FakeMarkdown


def test_create_gradio_interface_with_fake_gr_wires_and_runs(monkeypatch: Any) -> None:
    # Patch gr to fake implementation and flow factory
    monkeypatch.setattr(main_mod, "gr", FakeGradioModule())
    fake_flow = _patch_create_main_flow(monkeypatch)

    app = main_mod.create_gradio_interface()
    # app is our FakeBlocks instance
    assert isinstance(app, FakeBlocks)
    # Should have created some UI elements
    assert any(isinstance(c, FakeMarkdown) for c in app.components)
    assert len(app.textboxes) >= 2
    assert len(app.buttons) >= 1
    assert len(app.jsons) >= 1

    # Simulate clicking "Run" by invoking stored fn with user inputs
    result = app.test_run("Announce product", "twitter, linkedin")
    assert isinstance(result, dict)
    assert "twitter" in result
    assert "linkedin" in result
    assert result["twitter"].startswith("Draft for twitter: Announce product")
    assert len(fake_flow.runs) == 1
    # Validate that the shared passed into flow contained normalized platforms
    shared = fake_flow.runs[0]
    assert shared["task_requirements"]["platforms"] == ["twitter", "linkedin"]


def test_create_gradio_interface_platforms_parsing_trims_and_ignores_blanks(monkeypatch: Any) -> None:
    monkeypatch.setattr(main_mod, "gr", FakeGradioModule())
    fake_flow = _patch_create_main_flow(monkeypatch)

    app = main_mod.create_gradio_interface()
    messy = "  twitter ,  ,  linkedin  ,   "
    result = app.test_run("Launch X", messy)
    assert set(result.keys()) == {"twitter", "linkedin"}
    # Ensure flow saw cleaned list
    shared = fake_flow.runs[-1]
    assert shared["task_requirements"]["platforms"] == ["twitter", "linkedin"]


def test_create_gradio_interface_default_platform_when_empty(monkeypatch: Any) -> None:
    monkeypatch.setattr(main_mod, "gr", FakeGradioModule())
    fake_flow = _patch_create_main_flow(monkeypatch)

    app = main_mod.create_gradio_interface()
    # Provide empty/blank platforms -> code uses ["twitter"] fallback
    result = app.test_run("Topic", "   ")
    assert set(result.keys()) == {"twitter"}
    shared = fake_flow.runs[-1]
    assert shared["task_requirements"]["platforms"] == ["twitter"]
# === AUTO-GENERATED TESTS FOR main.py (Virtual PR Firm CLI/Gradio) END ===